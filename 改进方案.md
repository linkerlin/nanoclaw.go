# nanoclaw.go 改进方案

> 基于 Go 语言原生项目规范，以 bubbletea v2 / adk-go / gopher-lua 为基础，对 nanoclaw 进行精简复刻

---

## 一、设计原则

### 1.1 极简哲学

原版 NanoClaw 的核心价值：**500行代码，8分钟可完整阅读**。Go 复刻版遵循相同哲学：

- **文件数限制**：15个 `.go` 文件以内
- **代码行数**：核心逻辑 < 2000 行
- **零过度工程**：无 unnecessary abstraction

### 1.2 技术选型决策

| 组件 | 选型 | 理由 |
|------|------|------|
| 数据库 | **SQLite** (modernc.org/sqlite) | 单文件、无CGO、嵌入式 |
| 技能系统 | **Claude SKILL格式** + **Gopher-Lua** | 兼容原版 + 脚本扩展 |
| 隔离机制 | **低权限用户 nanoclaw** + **Unix Socket** | 轻量级、无Docker依赖 |
| 并发控制 | **golang.org/x/sync/semaphore** | Google官方、Weighted支持 |
| TUI框架 | **Bubbletea v2** | 最新稳定版、性能优化 |
| LLM后端 | **OpenAI兼容API** | 环境变量配置，多厂商支持 |

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        nanoclaw.go                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐ │
│  │   TUI       │───►│  Scheduler  │───►│   Agent (OpenAI)    │ │
│  │  (v2)       │    │  (cron)     │    │   GPT/Claude/etc    │ │
│  └─────────────┘    └─────────────┘    └─────────────────────┘ │
│         │                  │                      │             │
│         ▼                  ▼                      ▼             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Orchestrator                          │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │   Router    │  │    Queue    │  │  Trigger Detector│  │   │
│  │  │  (消息路由)  │  │  (semaphore)│  │   (@Andy检测)    │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
│         │                  │                      │             │
│         ▼                  ▼                      ▼             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                      Storage Layer                       │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │   SQLite    │  │   Session   │  │   Skills (Lua)  │  │   │
│  │  │  (messages) │  │   (DB存储)   │  │  (.claude/)     │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Isolation Layer                        │   │
│  │         User: nanoclaw  │  Socket: /var/run/nanoclaw/    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 目录结构（精简版）

```
nanoclaw.go/
├── cmd/
│   └── nanoclaw/
│       └── main.go                    # 入口（<100行）
├── internal/                          # 私有代码
│   ├── domain.go                      # 核心领域模型（合并core+types）
│   ├── config.go                      # 配置（单文件）
│   ├── db.go                          # SQLite操作（无repository层）
│   ├── queue.go                       # Semaphore队列
│   ├── orchestrator.go                # 消息编排
│   ├── agent.go                       # ADK-GO封装
│   ├── scheduler.go                   # 定时任务
│   ├── skills.go                      # Claude SKILL + Lua支持
│   ├── tui.go                         # Bubbletea v2 TUI
│   └── ipc.go                         # Unix Socket IPC
├── skills/                            # 内置Skills
│   ├── builtin/
│   │   ├── task.lua                   # 任务管理
│   │   └── group.lua                  # 群组管理
│   └── loader.go
├── scripts/                           # 工具脚本
│   └── setup.sh                       # 创建nanoclaw用户
├── groups/                            # 群组数据
│   └── main/
│       ├── CLAUDE.md
│       └── skills/                    # 群组自定义Skills
├── data/                              # SQLite数据库
│   └── nanoclaw.db
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

---

## 三、核心实现方案

### 3.1 数据库层（SQLite）

```go
// internal/db.go
package internal

import (
    "database/sql"
    "embed"
    _ "modernc.org/sqlite"
)

//go:embed schema.sql
var schemaFS embed.FS

type DB struct {
    *sql.DB
}

func OpenDB(path string) (*DB, error) {
    db, err := sql.Open("sqlite", path)
    if err != nil {
        return nil, err
    }
    // 执行嵌入的schema
    schema, _ := schemaFS.ReadFile("schema.sql")
    if _, err := db.Exec(string(schema)); err != nil {
        return nil, err
    }
    return &DB{db}, nil
}

// 直接操作方法，无repository抽象
func (d *DB) SaveMessage(m *Message) error
func (d *DB) GetMessages(chatJID string, limit int) ([]Message, error)
func (d *DB) GetSession(groupFolder string) (*Session, error)
func (d *DB) SaveSession(s *Session) error
```

**schema.sql**:
```sql
CREATE TABLE IF NOT EXISTS messages (
    id TEXT PRIMARY KEY,
    chat_jid TEXT NOT NULL,
    sender TEXT,
    content TEXT,
    timestamp TEXT,
    is_bot INTEGER DEFAULT 0
);

CREATE TABLE IF NOT EXISTS sessions (
    group_folder TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    updated_at TEXT
);

CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    group_folder TEXT,
    prompt TEXT,
    schedule_type TEXT,  -- cron/interval/once
    schedule_value TEXT,
    next_run TEXT,
    status TEXT DEFAULT 'active'
);
```

### 3.2 Semaphore 队列（Google官方）

```go
// internal/queue.go
package internal

import (
    "context"
    "golang.org/x/sync/semaphore"
)

// GroupQueue 使用Google官方semaphore实现加权并发控制
type GroupQueue struct {
    sem     *semaphore.Weighted    // 全局并发限制
    perGroup map[string]chan func() // 每群组FIFO
}

func NewGroupQueue(maxConcurrent int64) *GroupQueue {
    return &GroupQueue{
        sem:       semaphore.NewWeighted(maxConcurrent),
        perGroup:  make(map[string]chan func()),
    }
}

func (q *GroupQueue) Enqueue(ctx context.Context, group string, job func()) error {
    // 获取权重1的许可
    if err := q.sem.Acquire(ctx, 1); err != nil {
        return err
    }
    
    // 执行后释放
    go func() {
        defer q.sem.Release(1)
        job()
    }()
    return nil
}
```

**依赖**: `go get golang.org/x/sync/semaphore`

### 3.3 Claude SKILL 格式支持

```go
// internal/skills.go
package internal

import (
    "github.com/yuin/gopher-lua"
)

// Skill 对应原版 .claude/skills/{name}/SKILL.md 格式
type Skill struct {
    Name        string
    Description string
    Version     string
    Steps       []SkillStep
    LuaScript   string           // Gopher-Lua扩展
}

type SkillStep struct {
    Action string                 // file_edit/file_create/command
    Params map[string]string
}

// LoadClaudeSkill 从目录加载原版Claude SKILL格式
func LoadClaudeSkill(dir string) (*Skill, error) {
    // 解析 SKILL.md (YAML frontmatter + markdown)
    // 加载可选的 script.lua
}

// Execute 执行Skill
func (s *Skill) Execute(L *lua.LState, ctx SkillContext) error {
    // 1. 执行Claude格式的steps
    for _, step := range s.Steps {
        if err := executeStep(step); err != nil {
            return err
        }
    }
    
    // 2. 执行Lua脚本扩展
    if s.LuaScript != "" {
        if err := L.DoString(s.LuaScript); err != nil {
            return err
        }
    }
    return nil
}
```

**Lua绑定示例**:
```lua
-- skills/builtin/task.lua
function create_task(group, prompt, schedule)
    local task = {
        id = uuid(),
        group_folder = group,
        prompt = prompt,
        schedule_type = schedule.type,
        schedule_value = schedule.value
    }
    db:exec("INSERT INTO tasks ...", task)
    return task.id
end

function list_tasks(group)
    return db:query("SELECT * FROM tasks WHERE group_folder = ?", group)
end
```

### 3.4 低权限用户隔离

```go
// internal/ipc.go
package internal

import (
    "net"
    "os/user"
)

// IPCServer Unix Socket通信，配合低权限用户隔离
type IPCServer struct {
    socketPath string
    listener   net.Listener
}

func NewIPCServer(socketDir string) (*IPCServer, error) {
    // 确保目录权限: drwxr-xr-x nanoclaw nanoclaw
    // Socket文件权限: srwxr-xr-x
    
    socketPath := filepath.Join(socketDir, "nanoclaw.sock")
    
    // 创建Unix Socket
    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        return nil, err
    }
    
    // 设置权限，只允许nanoclaw用户组访问
    if err := os.Chmod(socketPath, 0770); err != nil {
        return nil, err
    }
    
    return &IPCServer{socketPath, listener}, nil
}

// RunAgentInUser 以nanoclaw用户身份运行Agent
func RunAgentInUser(socketPath string, req AgentRequest) (*AgentResponse, error) {
    // 1. 检查当前用户
    current, _ := user.Current()
    
    // 2. 如果已经是nanoclaw用户，直接执行
    if current.Username == "nanoclaw" {
        return runAgentDirect(req)
    }
    
    // 3. 否则通过Unix Socket发送给nanoclaw守护进程
    conn, err := net.Dial("unix", socketPath)
    if err != nil {
        return nil, err
    }
    defer conn.Close()
    
    // 发送请求，接收响应
    encoder := json.NewEncoder(conn)
    decoder := json.NewDecoder(conn)
    
    if err := encoder.Encode(req); err != nil {
        return nil, err
    }
    
    var resp AgentResponse
    if err := decoder.Decode(&resp); err != nil {
        return nil, err
    }
    return &resp, nil
}
```

**setup.sh** - 创建隔离用户:
```bash
#!/bin/bash
# scripts/setup.sh

# 创建低权限用户
sudo useradd -r -s /bin/false -M nanoclaw 2>/dev/null || true

# 创建socket目录
sudo mkdir -p /var/run/nanoclaw
sudo chown nanoclaw:nanoclaw /var/run/nanoclaw
sudo chmod 755 /var/run/nanoclaw

# 创建数据目录
sudo mkdir -p /var/lib/nanoclaw
sudo chown nanoclaw:nanoclaw /var/lib/nanoclaw

# 设置capabilities（允许绑定低端口等，可选）
# sudo setcap cap_net_bind_service=+ep ./nanoclaw

echo "Setup complete. Run with: sudo -u nanoclaw ./nanoclaw"
```

### 3.5 LLM Agent 实现（OpenAI兼容）

```go
// internal/agent.go
package internal

import (
    "context"
    "os"
    
    "github.com/sashabaranov/go-openai"
)

// Agent LLM代理，支持OpenAI兼容API
type Agent struct {
    client *openai.Client
    model  string
    db     *DB
}

// NewAgent 从环境变量创建Agent
func NewAgent(db *DB) *Agent {
    apiKey := os.Getenv("OPENAI_API_KEY")
    if apiKey == "" {
        panic("OPENAI_API_KEY is required")
    }
    
    baseURL := os.Getenv("OPENAI_BASE_URL")
    if baseURL == "" {
        baseURL = "https://api.openai.com/v1"
    }
    
    model := os.Getenv("OPENAI_MODEL")
    if model == "" {
        model = "gpt-4o-mini"
    }
    
    config := openai.DefaultConfig(apiKey)
    config.BaseURL = baseURL
    
    return &Agent{
        client: openai.NewClientWithConfig(config),
        model:  model,
        db:     db,
    }
}

// Run 执行单次对话
func (a *Agent) Run(ctx context.Context, sessionID string, messages []Message) (string, error) {
    // 构建OpenAI消息格式
    var msgs []openai.ChatCompletionMessage
    for _, m := range messages {
        role := openai.ChatMessageRoleUser
        if m.IsBotMessage {
            role = openai.ChatMessageRoleAssistant
        }
        msgs = append(msgs, openai.ChatCompletionMessage{
            Role:    role,
            Content: m.Content,
        })
    }
    
    // 调用API
    resp, err := a.client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
        Model:    a.model,
        Messages: msgs,
    })
    if err != nil {
        return "", err
    }
    
    if len(resp.Choices) == 0 {
        return "", fmt.Errorf("no response from LLM")
    }
    
    return resp.Choices[0].Message.Content, nil
}

// RunStream 流式执行（SSE）
func (a *Agent) RunStream(ctx context.Context, sessionID string, messages []Message) (<-chan StreamEvent, error) {
    stream, err := a.client.CreateChatCompletionStream(ctx, openai.ChatCompletionRequest{
        Model:    a.model,
        Messages: convertMessages(messages),
        Stream:   true,
    })
    if err != nil {
        return nil, err
    }
    
    ch := make(chan StreamEvent)
    go func() {
        defer close(ch)
        defer stream.Close()
        
        for {
            select {
            case <-ctx.Done():
                ch <- StreamEvent{Err: ctx.Err()}
                return
            default:
                response, err := stream.Recv()
                if err != nil {
                    if err != io.EOF {
                        ch <- StreamEvent{Err: err}
                    }
                    return
                }
                if len(response.Choices) > 0 {
                    ch <- StreamEvent{
                        Content: response.Choices[0].Delta.Content,
                    }
                }
            }
        }
    }()
    
    return ch, nil
}
```

**环境变量配置示例**:

```bash
# OpenAI官方
export OPENAI_API_KEY="sk-..."
export OPENAI_BASE_URL="https://api.openai.com/v1"
export OPENAI_MODEL="gpt-4o"

# Groq（高速推理）
export OPENAI_API_KEY="gsk_..."
export OPENAI_BASE_URL="https://api.groq.com/openai/v1"
export OPENAI_MODEL="llama-3.3-70b-versatile"

# DeepSeek
export OPENAI_API_KEY="sk-..."
export OPENAI_BASE_URL="https://api.deepseek.com/v1"
export OPENAI_MODEL="deepseek-chat"

# 本地Ollama
export OPENAI_API_KEY="ollama"
export OPENAI_BASE_URL="http://localhost:11434/v1"
export OPENAI_MODEL="qwen2.5:14b"
```

### 3.6 Bubbletea v2 升级

```go
// internal/tui.go
package internal

import (
    tea "github.com/charmbracelet/bubbletea/v2"
    "github.com/charmbracelet/bubbles/v2/list"
    "github.com/charmbracelet/bubbles/v2/textarea"
    "github.com/charmbracelet/bubbles/v2/viewport"
)

// Model v2版本适配
type TUIModel struct {
    width, height int
    
    // v2新特性：真正的光标控制
    groupList list.Model
    viewport  viewport.Model
    input     textarea.Model
    
    // 焦点管理
    focus FocusPane
    
    // 状态
    messages map[string][]Message
    thinking map[string]bool
}

// Init v2新接口
func (m TUIModel) Init() (tea.Model, tea.Cmd) {
    return m, tea.Batch(
        textarea.Blink,
        tea.EnterAltScreen,
    )
}

// Update v2优化的事件处理
func (m TUIModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.WindowSizeMsg:
        // v2: 更精确的尺寸计算
        m.width = msg.Width
        m.height = msg.Height
        m.recalcLayout()
        
    case tea.KeyMsg:
        // v2: 增强的键盘事件
        switch msg.Key() {
        case tea.KeyCtrlC:
            return m, tea.Quit
        case tea.KeyTab:
            m.focus = m.focus.Next()
        }
        
    case BotResponseMsg:
        // 处理Agent响应
        m.messages[msg.ChatJID] = append(
            m.messages[msg.ChatJID],
            msg.Message,
        )
        m.updateViewport(msg.ChatJID)
    }
    
    return m, nil
}

// View v2: 视图接口分离
func (m TUIModel) View() string {
    // 三栏布局
    sidebar := m.renderSidebar()
    main := m.renderMain()
    input := m.renderInput()
    
    return lipgloss.JoinHorizontal(
        lipgloss.Top,
        sidebar,
        lipgloss.JoinVertical(lipgloss.Left, main, input),
    )
}
```

**go.mod 更新**:
```
require (
    github.com/charmbracelet/bubbletea/v2 v2.0.0-beta.1
    github.com/charmbracelet/bubbles/v2 v2.0.0-beta.1
    github.com/charmbracelet/lipgloss v1.0.0
    golang.org/x/sync v0.11.0
    github.com/yuin/gopher-lua v1.1.1
    modernc.org/sqlite v1.34.5
    google.golang.org/adk v0.5.0
)
```

---

## 四、依赖选型

### 4.1 核心依赖

| 功能 | 库 | 版本 |
|------|-----|------|
| TUI框架 | `github.com/charmbracelet/bubbletea/v2` | v2.0.0-beta+ |
| TUI组件 | `github.com/charmbracelet/bubbles/v2` | v2.0.0-beta+ |
| 样式 | `github.com/charmbracelet/lipgloss` | v1.0.0 |
| 并发控制 | `golang.org/x/sync/semaphore` | latest |
| 数据库 | `modernc.org/sqlite` | v1.34+ |
| Lua引擎 | `github.com/yuin/gopher-lua` | v1.1+ |
| LLM客户端 | `github.com/sashabaranov/go-openai` | v1.36+ |
| Cron | `github.com/robfig/cron/v3` | v3.0+ |
| UUID | `github.com/google/uuid` | v1.6+ |

### 4.2 依赖安装

```bash
go get github.com/charmbracelet/bubbletea/v2@latest
go get github.com/charmbracelet/bubbles/v2@latest
go get golang.org/x/sync/semaphore
go get github.com/yuin/gopher-lua
go get modernc.org/sqlite
go get github.com/sashabaranov/go-openai
go get github.com/robfig/cron/v3
```

---

## 五、实施路线图

### Phase 1: 基础重构（1周）

- [ ] 合并 domain.go（core+types）
- [ ] 简化 config.go（单文件）
- [ ] 重构 db.go（SQLite，无repository）
- [ ] 实现 semaphore 队列

### Phase 2: Bubbletea v2 升级（3天）

- [ ] 升级依赖到 v2
- [ ] 适配新API（Init/Update/View）
- [ ] 光标控制优化

### Phase 3: Skills系统（1周）

- [ ] 集成 Gopher-Lua
- [ ] 实现 Claude SKILL 解析器
- [ ] 内置 Skills (task/group)

### Phase 4: 用户隔离（3天）

- [ ] Unix Socket IPC实现
- [ ] setup.sh 脚本
- [ ] 低权限用户运行测试

### Phase 5: 完善（3天）

- [ ] 表驱动测试（60%覆盖）
- [ ] Makefile
- [ ] 文档

---

## 六、关键代码示例

### 6.1 完整主程序

```go
// cmd/nanoclaw/main.go
package main

import (
    "context"
    "log/slog"
    "os"
    "os/signal"
    "syscall"
    
    "nanoclaw.go/internal"
)

func main() {
    // 初始化日志
    slog.SetDefault(slog.New(slog.NewJSONHandler(os.Stderr, nil)))
    
    // 打开数据库
    db, err := internal.OpenDB("data/nanoclaw.db")
    if err != nil {
        slog.Error("open db", "err", err)
        os.Exit(1)
    }
    defer db.Close()
    
    // 初始化组件
    cfg := internal.LoadConfig()
    queue := internal.NewGroupQueue(cfg.MaxConcurrent)
    agent := internal.NewAgent(db)  // 从环境变量读取LLM配置
    scheduler := internal.NewScheduler(db, agent)
    
    // 创建TUI
    tui := internal.NewTUI(db, queue, agent)
    
    // 启动
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    scheduler.Start(ctx)
    defer scheduler.Stop()
    
    // 信号处理
    sigs := make(chan os.Signal, 1)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
    go func() {
        <-sigs
        cancel()
    }()
    
    // 运行TUI
    if err := tui.Run(ctx); err != nil {
        slog.Error("tui error", "err", err)
        os.Exit(1)
    }
}
```

### 6.2 文件清单（目标）

| 文件 | 行数目标 | 说明 |
|------|---------|------|
| `main.go` | <100 | 入口 |
| `domain.go` | <150 | 领域模型 |
| `config.go` | <100 | 配置 |
| `db.go` | <200 | SQLite操作 |
| `queue.go` | <100 | Semaphore队列 |
| `orchestrator.go` | <200 | 消息编排 |
| `agent.go` | <200 | ADK封装 |
| `scheduler.go` | <150 | 定时任务 |
| `skills.go` | <200 | SKILL+Lua |
| `tui.go` | <300 | Bubbletea v2 |
| `ipc.go` | <150 | Unix Socket |
| **总计** | **<1850** | **15文件内** |

---

## 七、与原版的差异

| 特性 | 原版 (TypeScript) | Go复刻版 |
|------|------------------|----------|
| 代码行数 | ~500行 | ~1800行（Go更冗长） |
| 容器隔离 | Docker/Apple Container | 低权限用户+Socket |
| Skills引擎 | Claude Agent SDK | Gopher-Lua |
| 数据库 | better-sqlite3 | modernc.org/sqlite |
| 消息队列 | 自定义FIFO | Google Semaphore |
| TUI | 无（纯IM） | Bubbletea v2 |
| LLM后端 | Claude Agent SDK | OpenAI兼容API |

---

## 八、参考资源

- [Bubbletea v2](https://github.com/charmbracelet/bubbletea/tree/v2)
- [golang.org/x/sync](https://pkg.go.dev/golang.org/x/sync)
- [Gopher-Lua](https://github.com/yuin/gopher-lua)
- [modernc.org/sqlite](https://pkg.go.dev/modernc.org/sqlite)
- [NanoClaw原版](https://github.com/qwibitai/nanoclaw)

---

*文档版本: v2.0*
*最后更新: 2026-02-28*
